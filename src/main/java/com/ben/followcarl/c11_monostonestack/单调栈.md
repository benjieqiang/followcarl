暴力解法是on2

# 单调栈:
使用空间换时间, 优化成on
寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置
# 单调栈放什么:
存放遍历数组时的下标, 取得时候只需nums[i];

# 单调栈的顺序:
递增单调栈: 栈顶到栈底单调递增的;从小到大的
递减单调栈: 栈顶到栈底是单调递增的;

求右边第一个比自己大的，单调栈就是递增的，
求右边第一个比自己小的，单调栈就是递减的

# 三个条件
三个判断条件。
当前遍历的元素T[i]小于栈顶元素T[st.pop()]的情况
当前遍历的元素T[i]等于栈顶元素T[st.pop()]的情况
当前遍历的元素T[i]大于栈顶元素T[st.pop()]的情况

# 题目理解
所以每日温度就是用:
递增的单调栈: 从栈顶到栈头的单调栈;
思路:
单调栈的栈顶元素存放数组的下标, 每次过来拿单调栈的栈顶元素对应的值和当前遍历的元素的值比较l1
1. 当前遍历值小于等于栈顶元素对应的值, 入栈, 保证是一个单调栈, 这样栈里面记录的是遍历过的元素的位置;
2. 当前遍历的值大于栈顶元素对应的值, 出栈, 计算当前温度遇到下一个温度的距离,