package com.ben.followcarl.acm;

/**
 * @Author: benjieqiang
 * @CreateTime: 2023-08-17  15:08
 * @Description:
 *
 * 题目描述
 * 给定一个字符串 S，只包含 0 和 1 两个数字，下标从 1 开始，设第 i 位的价值为 vali，则vali的定义如下：
 *
 * 当 i = 1 时：val1 = 1；
 *
 * 当 i > 1 时：
 *     若Si != S(i - 1)：vali = 1，
 *
 *     若Si == S(i - 1)：vali = val(i - 1) + 1；
 *
 * 字符串 S 的总价值等于 val1 + val2 + ... + valn（n为字符串 S 的长度）。
 * 你可以任意删除字符串 S 中的任意字符，使得字符串 S 的总价值能够达到最大
 *
 *
1. 第一个字符的价值为 1（即 val1 = 1）。

2. 对于后续字符（下标大于1的位置）：
- 如果当前字符与前一个字符不相同（即 Si ≠ S(i - 1)），则当前字符的价值为 1（即 vali = 1）。
- 如果当前字符与前一个字符相同（即 Si == S(i - 1)），则当前字符的价值为前一个字符的价值加1（即 vali = val(i - 1) + 1）。

字符串 S 的总价值等于各个字符的价值之和，即 val1 + val2 + ... + valn，其中 n 为字符串 S 的长度。

你的任务是通过删除字符串 S 中的某些字符，使得最终字符串的总价值达到最大。

换句话说，你可以通过删除字符串中的一些字符，从而构建一个新的字符串，使得新字符串的字符顺序保持原有顺序，但总价值最大化。要达到最大价值，你需要考虑如何在保持字符顺序的情况下，尽可能多地保留连续相同字符的片段，因为这会增加这些片段的总价值。

根据题目描述的规则，对字符串 "0111" 进行计算：

- val1 = 1
- val2 = 1 (因为 0 ≠ 1)
- val3 = 2 (1 + 1, 因为 1 = 1)
- val4 = 3 (2 + 1, 因为 1 = 1)
总价值 = 1 + 1 + 2 + 3 = 7。

在这个例子中，你可以通过删除一些字符来构造新的字符串，例如 "10101" 或 "111"，从而使总价值达到最大值。
输入: 010101
输出: 7

思路:
尽可能保证多的连续的0或1出现, 如果避免不了, 不同的数字最少;

首先，使用 count 数组来记录字符 '0' 和 '1' 的个数。
对于每个字符 '0' 和 '1'，都分别计算以其为分界的情况下的价值。

对于以字符 '0' 为分界的情况：

1. 找到第一个字符 '0' 出现的位置 start 和最后一个字符 '0' 出现的位置 end。
2. 计算连续字符 '0' 所对应的价值：(1 + count[c - '0']) * count[c - '0'] / 2，
    其中 count[c - '0'] 是字符 '0' 的个数。也就是将 '0' 之间的所有 ‘1’ 逻辑上删除。
3. 计算字符 '0' 之前连续字符 '1' 所对应的价值：(1 + start) * start / 2。
4. 计算字符 '0' 之后连续字符 '1' 所对应的价值：(s.length() - end) * (s.length() - end - 1L) / 2，这里要注意长度减1。


这段代码 `(1 + count[c - '0']) * count[c - '0'] / 2` 的目的是计算连续字符 `c` 所对应的价值。让我一步步解释这段代码的含义：

1. `c` 是当前要计算价值的字符，可以是 `'0'` 或 `'1'`。
2. `count[c - '0']` 表示字符 `c` 在字符串中出现的次数。如果 `c` 是 `'0'`，那么 `count[0]` 就是 `'0'` 的个数，如果 `c` 是 `'1'`，那么 `count[1]` 就是 `'1'` 的个数。
3. `(1 + count[c - '0'])` 表示 `1` 加上字符 `c` 在字符串中出现的次数。这是因为题目中规定当 `i = 1` 时，字符的价值是 `1`。
4. `(1 + count[c - '0']) * count[c - '0']` 计算的是连续字符 `c` 在字符串中出现的次数与字符 `c` 自身价值的乘积。这一步计算的结果就是将所有连续字符 `c` 的价值相加，也就是去掉逻辑上的中间部分，只保留连续的起始和结束字符的价值。
5. `(1 + count[c - '0']) * count[c - '0'] / 2` 将上一步计算的结果除以 2，这是因为在计算价值时，我们考虑的是字符的连续片段，而不是每个字符单独的价值。除以 2 是为了将字符片段的价值平均分配到每个字符上，以符合问题描述中的规则。

综上所述，`(1 + count[c - '0']) * count[c - '0'] / 2` 这段代码实际上是在计算连续字符 `c` 的价值，考虑了字符的个数和位置信息，然后将这个价值平均分配给每个字符。这样做的目的是为了在保持连续片段的情况下，计算字符片段的总价值。
同样的，对于以字符 '1' 为分界的情况，重复上述步骤。
 * @Version: 1.0
 */
import java.util.Scanner;

public class L31_StringMaxVal {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String str = sc.nextLine();
        sc.close();

        int[] count = new int[2]; // 统计字符'0'和'1'的出现次数
        for (char c : str.toCharArray()) {
            count[c - '0']++;
        }

        System.out.println(Math.max(getValue('0', str, count), getValue('1', str, count)));
    }

    private static long getValue(char ch, String str, int[] count) {
        int start = str.indexOf(ch); // 找到字符0的起始位置
        int end = str.lastIndexOf(ch); // 找到字符0的结束位置;

        long num = (1L + count[ch - '0']) * count[ch - '0'] / 2;
        num += (1L + start) * start / 2;
        num += (str.length() - end) * (str.length() - end - 1L) / 2;
        return num;
    }
}
